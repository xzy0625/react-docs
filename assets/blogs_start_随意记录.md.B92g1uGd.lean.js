import{_ as a,c as i,ag as e,o as t}from"./chunks/framework.B883bhfp.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"blogs/start/随意记录.md","filePath":"blogs/start/随意记录.md","lastUpdated":1734352047000}'),n={name:"blogs/start/随意记录.md"};function r(l,s,p,h,k,o){return t(),i("div",null,s[0]||(s[0]=[e(`<h3 id="优先级" tabindex="-1">优先级 <a class="header-anchor" href="#优先级" aria-label="Permalink to &quot;优先级&quot;">​</a></h3><ol><li>每次更新会产生一个update，这个update会有一个优先级。同时当前调度的环境也会有一个update。例如首次更新就会在updateContainer中调用scheduleUpdateOnFiber传入优先级</li><li>fiber优先级 -&gt; 事件优先级 -&gt; schduler优先级 -&gt; 过期时间 -&gt; sortIndex</li><li>在scheduleUpdateOnFiber中调用markRootUpdated会给root.pendingLanes标记上将要更新。后面schduler调用performConcurrentWorkOnRoot的时候就会从root.pendingLanes找到这次需要更新的最高优先级</li><li>每一次开始协调前会判断当前的workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes是不是相等。不想等说明之前的任务被高优先级的给取消了，所以这里需要调用prepareFreshStack重新准备一下这些优先级之类的。会调用createWorkInProgress</li></ol><h3 id="更新" tabindex="-1">更新 <a class="header-anchor" href="#更新" aria-label="Permalink to &quot;更新&quot;">​</a></h3><p>processUpdateQueue 调用getStateFromUpdate获取新状态。getStateFromUpdate中会根据update的tag进行不通的处理</p><h3 id="优先级-1" tabindex="-1">优先级 <a class="header-anchor" href="#优先级-1" aria-label="Permalink to &quot;优先级&quot;">​</a></h3><p>lanes在fiber和update上用。一般从EventPriority产生，但是非事件产生的就不是EventPriority来的了。例如使用useTransition lanesToEventPriority EventPriorityToSchedulerPriority</p><p>fiber的优先级 === 所有update优先级的merge</p><h3 id="初次渲染" tabindex="-1">初次渲染 <a class="header-anchor" href="#初次渲染" aria-label="Permalink to &quot;初次渲染&quot;">​</a></h3><p>fiberRootNode存储和渲染相关的所有内容，也就是整个应用的跟节点。例如渲染任务callbackNode，需要渲染的优先级，已经渲染好的fiber树等等 rootFiber #host (fiberRootNode.current) 存储的是fiber节点。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">createContainer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> createFiberRoot</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 创建fiberRootNode</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 创建</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">FiberNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root节点)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> root.current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> uninitializedFiber; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// rootFiber和fiberRoot互相指向</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  uninitializedFiber.stateNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> root;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 初始化uninitializedFiber的memoizedState和updateQueue</span></span></code></pre></div><h3 id="render" tabindex="-1">render <a class="header-anchor" href="#render" aria-label="Permalink to &quot;render&quot;">​</a></h3><p>render -&gt; updateContainer -&gt; scheduleUpdateOnFiber -&gt; ensureRootIsScheduled -&gt; performConcurrentWorkOnRoot</p><p>createFiberFromTypeAndProps 会用elemnt的type来确定fiber的tag从而进入 switch的不同case</p><h3 id="hooks" tabindex="-1">hooks <a class="header-anchor" href="#hooks" aria-label="Permalink to &quot;hooks&quot;">​</a></h3><p>ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV; // 不能嵌套使用hooks --- 防止嵌套</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// hooks在fiber的memoizedState上，张这样</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> hook</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Hook</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  memoizedState: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  baseState: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  baseQueue: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  queue: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  next: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// effect的节点，这个是存在fiber的updateQueue上，同时memoizedState上的memoizedState也会存一个</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> effect</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Effect</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// effect也是一个链表环</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  tag,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  create,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  destroy,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  deps,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Circular</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">null</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><h3 id="preparefreshstack" tabindex="-1">prepareFreshStack <a class="header-anchor" href="#preparefreshstack" aria-label="Permalink to &quot;prepareFreshStack&quot;">​</a></h3><p>prepareFreshStack中会调用createWorkInProgress创建wip。在createWorkInProgress会创建两个对象的引用 workInProgress.alternate = current; current.alternate = workInProgress; // 建立两棵树的相互引用。后面从hostRoot开始遍历的时候alternate就有值</p><p>performConcurrentWorkOnRoot(root, ..) // 这里的root是fiberRootNode</p><h3 id="flag" tabindex="-1">flag <a class="header-anchor" href="#flag" aria-label="Permalink to &quot;flag&quot;">​</a></h3><p>/Users/xzy/Desktop/reactSource/react-18.2.0/packages/react-reconciler/src/ReactFiberFlags.js</p><p>react-18.2.0/packages/react-reconciler/src/ReactHookEffectTags.js</p><h3 id="所有tag" tabindex="-1">所有tag <a class="header-anchor" href="#所有tag" aria-label="Permalink to &quot;所有tag&quot;">​</a></h3><p>react-18.2.0/packages/react-reconciler/src/ReactWorkTags.js</p><h3 id="update的tag" tabindex="-1">update的tag <a class="header-anchor" href="#update的tag" aria-label="Permalink to &quot;update的tag&quot;">​</a></h3><p>export const UpdateState = 0; export const ReplaceState = 1; export const ForceUpdate = 2; export const CaptureUpdate = 3;</p><h3 id="函数组件" tabindex="-1">函数组件 <a class="header-anchor" href="#函数组件" aria-label="Permalink to &quot;函数组件&quot;">​</a></h3><p>函数组件的updateQueue属性，存储的是副作用链表。包含useEffect和useLayoutEffect 函数组件的memoizedState属性，存储的是hooks链表</p><h3 id="低代码" tabindex="-1">低代码 <a class="header-anchor" href="#低代码" aria-label="Permalink to &quot;低代码&quot;">​</a></h3><p>低代码DSL -&gt; 统一渲染引擎。 宿主环境接入渲染引擎，传入DSL + 数据 + 渲染指令，渲染引擎渲染对应的样式。 建立一个DSL管理系统（模版管理系统）。管理所有的DSL，区分应用管理。 可以实现样式配置化，一分DSL可以在多个环境使用，不区分宿主环境 / 不区分项目的开发框架。</p>`,30)]))}const E=a(n,[["render",r]]);export{c as __pageData,E as default};
