import{_ as r,c as o,j as e,a as t,o as n}from"./chunks/framework.49dMbjpC.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"blogs/blog1/随意记录.md","filePath":"blogs/blog1/随意记录.md","lastUpdated":1731382108000}'),l={name:"blogs/blog1/随意记录.md"};function s(d,a,p,i,c,u){return n(),o("div",null,a[0]||(a[0]=[e("h3",{id:"优先级",tabindex:"-1"},[t("优先级 "),e("a",{class:"header-anchor",href:"#优先级","aria-label":'Permalink to "优先级"'},"​")],-1),e("ol",null,[e("li",null,"每次更新会产生一个update，这个update会有一个优先级。同时当前调度的环境也会有一个update。例如首次更新就会在updateContainer中调用scheduleUpdateOnFiber传入优先级"),e("li",null,"fiber优先级 -> 事件优先级 -> schduler优先级 -> 过期时间 -> sortIndex"),e("li",null,"在scheduleUpdateOnFiber中调用markRootUpdated会给root.pendingLanes标记上将要更新。后面schduler调用performConcurrentWorkOnRoot的时候就会从root.pendingLanes找到这次需要更新的最高优先级"),e("li",null,"每一次开始协调前会判断当前的workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes是不是相等。不想等说明之前的任务被高优先级的给取消了，所以这里需要调用prepareFreshStack重新准备一下这些优先级之类的。会调用createWorkInProgress")],-1),e("h3",{id:"更新",tabindex:"-1"},[t("更新 "),e("a",{class:"header-anchor",href:"#更新","aria-label":'Permalink to "更新"'},"​")],-1),e("p",null,"processUpdateQueue 调用getStateFromUpdate获取新状态。getStateFromUpdate中会根据update的tag进行不通的处理",-1)]))}const m=r(l,[["render",s]]);export{h as __pageData,m as default};
